floor(((columns)/10)*7.5)
##Transformation (see https://doi.org/10.1177%2F1469066720918446 and https://www.statology.org/transform-data-in-r/)
##Users can select different transformation styles here:
transformation <- "cube_root" # options are: log_2, log_10, square_root, cube_root
if(transformation == "cube_root"){
metabolomicsDataGroups_transformed <- cbind(metabolomicsDataGroups[,c(1:4)], metabolomicsDataGroups[,5:columns]^(1/3))
}else if(transformation == "square_root"){
metabolomicsDataGroups_transformed <- cbind(metabolomicsDataGroups[,c(1:4)], metabolomicsDataGroups[,5:columns]^(1/2))
}else if(transformation == "log_2"){
metabolomicsDataGroups_transformed <- cbind(metabolomicsDataGroups[,c(1:4)], log2(metabolomicsDataGroups[,5:columns]))
}else if(transformation == "log_10"){
metabolomicsDataGroups_transformed <- cbind(metabolomicsDataGroups[,c(1:4)], log10(metabolomicsDataGroups[,5:columns]))
}else{print("Warning: name for transformation not recognized")}
## Visualize the data before and after transformation (for one sample to get an idea of suitability of transformation:
#create histogram for original distribution for first column with data
hist(metabolomicsDataGroups[,5], col='steelblue', main='Original')
#create histogram for log-transformed distribution
hist(metabolomicsDataGroups_transformed[,5], col='coral2', main=transformation)
## Test if the transformation creates a normally distributed dataset (alpha >= 0.05)
##Calculate all Shapiro values for raw and transformed data:
metabolomicsDataGroups_Shapiro <- lapply(metabolomicsDataGroups[,5:columns], shapiro.test)
metabolomicsDataGroups_transformed_Shapiro <- lapply(metabolomicsDataGroups_transformed[,5:columns], shapiro.test)
#Obtain the p-values for raw and transformed data
metabolomicsDataGroups_Shapiro_pvalues <- do.call(rbind, metabolomicsDataGroups_Shapiro)
metabolomicsDataGroups_transformed_Shapiro_pvalues <- do.call(rbind, metabolomicsDataGroups_transformed_Shapiro)
## Count how often the p-value is above 0.05, to obtain an estimate of achieved normality due to transformation
metabolomicsDataGroups_Shapiro_pvalues_sum <- sum(metabolomicsDataGroups_Shapiro_pvalues[,2] >= 0.05, na.rm=TRUE)
metabolomicsDataGroups_transformed_Shapiro_pvalues_sum <- sum(metabolomicsDataGroups_transformed_Shapiro_pvalues[,2] >= 0.05, na.rm=TRUE)
seventyfive_percent <- floor(((columns)/10)*75)
#Print relevant information:
if(metabolomicsDataGroups_transformed_Shapiro_pvalues_sum[1] > seventyfive_percent ){paste0("Data after ", transformation ," transformation seems to follow a normal distribution for more then 80% of your data")} else{
print("Advised to select a different data transformation procedure")}
metabolomicsDataGroups_transformed_Shapiro_pvalues_sum[1]
floor(((columns)/10)*75)
seventyfive_percent <- floor(((columns)/10)*7.5)
#Print relevant information:
if(metabolomicsDataGroups_transformed_Shapiro_pvalues_sum[1] > seventyfive_percent ){paste0("Data after ", transformation ," transformation seems to follow a normal distribution for more then 80% of your data")} else{
print("Advised to select a different data transformation procedure")}
# Visualize all information in a heatmap
heatmaply::heatmaply(metabolomicsDataGroups_transformed[,5:103], grid_gap = 0, colors = heat.colors(200), showticklabels = c(T, F), margins = c(80, 10))
if(!"rstatix" %in% installed.packages()){install.packages("rstatix")}
library(rstatix)
if(!"rstatix" %in% installed.packages()){install.packages("rstatix")}
library(rstatix)
qqPlot(metabolomicsDataGroups_transformed$XXL.VLDL.PL_.)
?qqPlot
??qqPlo
??qqPlot
qqPlot(metabolomicsDataGroups_transformed$'XXL.VLDL.PL_.')
if(!"car" %in% installed.packages()){install.packages("car")}
library(car)
if(!"nloptr" %in% installed.packages()){install.packages("nloptr")}
if(!"car" %in% installed.packages()){install.packages("car")}
R.version()
version
library(car) #(Companion to Applied Regression)
# check if libraries are already installed > otherwise install it
if(!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager",repos = "http://cran.us.r-project.org")
if(!"dplyr" %in% installed.packages()) BiocManager::install("dplyr")
if(!"stringr" %in% installed.packages()){install.packages("stringr")}
#load libraries
library(dplyr)
library(stringr)
library(car) #(Companion to Applied Regression)
install.packages('car')
BiocManager::available('car')
BiocManager::install(car, type = "source", checkBuilt = TRUE)
BiocManager::install("car")
library(car) #(Companion to Applied Regression)
# Libraries
library(ggplot2)
library(dplyr)
library(forcats)
if(!"forcats" %in% installed.packages()){install.packages("forcats")}
library(forcats)
library(hrbrthemes)
if(!"hrbrthemes" %in% installed.packages()){install.packages("hrbrthemes")}
library(hrbrthemes)
knitr::opts_chunk$set(echo = TRUE)
if(!"knitr" %in% installed.packages()){
install.packages("knitr")
}
library(knitr)
knitr:::input_dir()
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("DESeq2")
BiocManager::install("ggplot2")
BiocManager::install("tidyr")
BiocManager::install("dplyr")
BiocManager::install("stringr")
BiocManager::install("ggfortify")
#load required libraries
library(DESeq2)
library(ggplot2)
library(ggfortify)
library(tidyr)
library(dplyr)
library(stringr)
#load raw count data and create some overview plots.
data = read.csv(file = 'GSE135448_geneCounts.csv', row.names = 1, header = TRUE)
View(data)
#Some raw count data visualisation with boxplot and PCA
boxplot(log(data))
PCA <- prcomp(t(data))
autoplot(PCA, label = TRUE, label.size = 3)
#Load the metadata file.
metadata <- read.table(file = 'SraRunTable_Diet.txt', sep = ",", header = TRUE)
View(metadata)
#Extract the intervention groups
groups <- factor(metadata$diet_intervention)
pca_df <- as.data.frame(PCA$x)
pca_df$Group <- groups
aytoplot(PCA, data=pca_df, colour='Group', label=TRUE, label.size=3)
autoplot(PCA, data=pca_df, colour='Group', label=TRUE, label.size=3)
#Create the "dds" object from count data and metadata. The experimental design compares via diagnosis (COS vs control). This is a design if you have only one variable to compare experimental groups.
dds <- DESeqDataSetFromMatrix(countData = data,
colData = metadata,
design = ~ diet_intervention, tidy = FALSE)
View(dds)
#Pre-filtering - technically not required, but will reduce memory size and increase speed if we remove samples with too low read counts.
smallestGroupSize <- 3
keep <- rowSums(counts(dds) >= 10) >= smallestGroupSize
dds <- dds[keep,]
#run the DESeq2 function. This will take a while (up to 10 min are normal).
dds <- DESeq(dds)
#result output
resultsNames(dds)
DEG <- results(dds)
View(dds)
View(DEG)
DEG
#export the complete result file to CSV for later analysis
write.csv(DEG, file = "DEG_LPvsHP.csv")
#all significantly changed genes, all significantly upregulated genes, all significantly downregulated genes
SigDEG <- DEG[DEG$pvalue < 0.05,]
write.csv(SigDEG, file = "SigDEG_LPvsHP.csv")
SigUP <- DEG[DEG$pvalue < 0.05 & DEG$log2FoldChange > 1,]
write.csv(SigUP, file = "SigUP_LPvsHP.csv")
SigDOWN <- DEG[DEG$pvalue < 0.05 & DEG$log2FoldChange < -1,]
write.csv(SigDOWN, file = "SigDOWN_LPvsHP.csv")
dim(SigUP)
DEG$padj
#export the complete result file to CSV for later analysis
write.csv(DEG, file = "DEG_LPvsHP.csv")
#all significantly changed genes, all significantly upregulated genes, all significantly downregulated genes
SigDEG <- DEG[DEG$pvalue < 0.05,]
write.csv(SigDEG, file = "SigDEG_LPvsHP.csv")
SigUP <- DEG[DEG$pvalue < 0.05 & DEG$log2FoldChange > 0.26,]
write.csv(SigUP, file = "SigUP_LPvsHP.csv")
SigDOWN <- DEG[DEG$pvalue < 0.05 & DEG$log2FoldChange < -0.26,]
write.csv(SigDOWN, file = "SigDOWN_LPvsHP.csv")
#Visualisation and interpretation of the results and the process
#sort by log2FC
DEG <- DEG[order(DEG$log2FoldChange),]
head(DEG)
#Volcano plot
par(mfrow=c(1,1))
# Make a basic volcano plot
with(DEG, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot", xlim=c(-6,6)))
# Add colored points: blue if log2FC < -1 and padj<0.05 and red if log2FC > 1 and padj<0.05)
with(subset(DEG, padj<0.05 & log2FoldChange < -1), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(DEG, padj<0.05 & log2FoldChange > 1), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
#Volcano plot
par(mfrow=c(1,1))
# Make a basic volcano plot
with(DEG, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot", xlim=c(-6,6)))
# Add colored points: blue if log2FC < -1 and padj<0.05 and red if log2FC > 1 and padj<0.05)
with(subset(DEG, padj<0.05 & log2FoldChange < -0.26), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(DEG, padj<0.05 & log2FoldChange > 0.26), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
#compare normalised counts vs. raw counts
dds_n <- estimateSizeFactors(dds);
dds_n <- counts(dds_n, normalized=TRUE)
boxplot(log(dds_n))
PCA <- prcomp(t(dds_n))
autoplot(PCA, label = TRUE, label.size = 3)
PCA <- prcomp(t(dds_n))
pca_df <- as.data.frame(PCA$x)
pca_df$Group <- groups
autoplot(PCA, label = TRUE, label.size = 3)
PCA <- prcomp(t(dds_n))
pca_df <- as.data.frame(PCA$x)
pca_df$Group <- groups
autoplot(PCA, label = TRUE, data = pca_df, colour='Group', label.size = 3)
?DESeq
if(!"knitr" %in% installed.packages()){
install.packages("knitr")
}
library(knitr)
knitr:::input_dir()
rm(list=ls())
# general config
baseDir <- 'datasets/'
bgxfile <- 'Annot/HumanHT-12_V4_0_R2_15002873_B.bgx'
setwd(baseDir)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("limma")
BiocManager::install("illuminaio")
BiocManager::install("tidyverse")
BiocManager::install("PCAtools")
BiocManager::install("ggplot2")
BiocManager::install("Biobase")
install.packages("RColorBrewer")
#load required libraries
library(limma)
library(RColorBrewer)
library(illuminaio)
library(tidyverse)
library(PCAtools)
library(ggplot2)
library(Biobase)
# read in the data and convert the data to an EListRaw object, which is a data object for single channel data
x <- read.table(paste0(baseDir, 'GSE176043_non-normalized.txt'),
header = TRUE, sep = '\t', stringsAsFactors = FALSE)
# read in the data and convert the data to an EListRaw object, which is a data object for single channel data
x <- read.table(paste0(baseDir, 'GSE176043_non-normalized.txt'),
header = TRUE, sep = '\t', stringsAsFactors = FALSE)
newnames <- colnames(read.table(paste0(baseDir, 'GSE176043_non-normalized.txt'),
header = TRUE, sep = '\t', stringsAsFactors = FALSE))
detectionpvalues <- x[,grep('Detection.Pval', colnames(x))]
x <- x[,-grep('Detection.Pval', colnames(x))]
probes <- x$ID.Ref
x <- data.matrix(x[,2:ncol(x)])
rownames(x) <- probes
#plot the expression data (before normalisation)
png("before norm.png", width = 1000, height = 500)
box_plot_data<-as.data.frame(log2(x))
par(mar=c(5,6,4,1)+.1)
boxplot(box_plot_data, main="Before background correction and normalisation",
xlab="Samples",ylab=expression('log'[2]*'(expression)'),cex=0.5, par(cex.lab=1.5),par(cex.axis=1.5))
dev.off()
# read in annotation Illumina Annotation file
annot <- illuminaio::readBGX('Annot/HumanHT-12_V4_0_R2_15002873_B.bgx')$probes
annot <- annot[,which(colnames(annot) %in% c('Source','Symbol','Transcript','ILMN_Gene','RefSeq_ID',
'Entrez_Gene_ID','Symbol','Protein_Product','Probe_Id','Probe_Type',
'Probe_Start','Chromosome','Probe_Chr_Orientation','Probe_Coordinates',
'Cytoband', 'Definition', 'Ontology_Component', 'Ontology_Process',
'Ontology_Function', 'Synonyms'))]
annot <- annot[which(annot$Probe_Id %in% rownames(x)),]
annot <- annot[match(rownames(x), annot$Probe_Id),]
# read in target file, this file contains the information about the timepoint and diet group
targets <- read.csv('datasets/targets.csv')
# create a custom EListRaw object
project <- new('EListRaw')
project@.Data[[1]] <- 'illumina'
project@.Data[[2]] <- NULL
project@.Data[[3]] <- annot
project@.Data[[3]] <- NULL
project@.Data[[4]] <- x
project@.Data[[5]] <- NULL
project$E <- x
project$targets <- NULL
project$genes <- annot
project$genes <- NULL
project$other$Detection <- detectionpvalues
View(annot)
project.bgcorrect.norm <- neqc(project, offset = 16)
# filter out control probes, those with no symbol, and those that failed
annot <- annot[which(annot$Probe_Id %in% rownames(project.bgcorrect.norm)),]
project.bgcorrect.norm <- project.bgcorrect.norm[which(rownames(project.bgcorrect.norm) %in% annot$Probe_Id),]
annot <- annot[match(rownames(project.bgcorrect.norm), annot$Probe_Id),]
project.bgcorrect.norm@.Data[[3]] <- annot
project.bgcorrect.norm$genes <- annot
Control <- project.bgcorrect.norm$genes$Source=="ILMN_Controls"
NoSymbol <- project.bgcorrect.norm$genes$Symbol == ""
isexpr <- rowSums(project.bgcorrect.norm$other$Detection <= 0.01) >= 5
project.bgcorrect.norm.filt <- project.bgcorrect.norm[!Control & !NoSymbol & isexpr, ]
dim(project.bgcorrect.norm)
dim(project.bgcorrect.norm.filt)
# remove annotation columns we no longer need
project.bgcorrect.norm.filt$genes <- project.bgcorrect.norm.filt$genes[,c(
'Probe_Id', 'Entrez_Gene_ID',
'Definition','Ontology_Component','Ontology_Process','Ontology_Function',
'Chromosome','Probe_Coordinates','Cytoband','Probe_Chr_Orientation',
'RefSeq_ID','Entrez_Gene_ID','Symbol')]
head(project.bgcorrect.norm.filt$genes)
# summarise across genes by mean
# ID is used to identify the replicates
project.bgcorrect.norm.filt.mean <- avereps(project.bgcorrect.norm.filt,
ID = project.bgcorrect.norm.filt$genes$Entrez_Gene_ID)
dim(project.bgcorrect.norm.filt.mean)
expression_data<-as.data.frame(project.bgcorrect.norm.filt.mean[["E"]])
#plot the expression data (before normalisation)
png("after norm.png", width = 1000, height = 500)
par(mar=c(5,6,4,1)+.1)
boxplot(expression_data, main="After background correction and normalisation",
xlab="Samples",ylab=expression('log'[2]*'(expression)'),cex=0.5, par(cex.lab=1.5),par(cex.axis=1.5))
dev.off()
#calculate no of samples below p values of 0.01
boolean_values<-detection_probe<0.01
expression_data<-as.data.frame(project.bgcorrect.norm.filt.mean[["E"]])
detection_probe<-as.data.frame(project.bgcorrect.norm.filt.mean[["other"]][["Detection"]])
#plot the expression data (before normalisation)
png("after norm.png", width = 1000, height = 500)
par(mar=c(5,6,4,1)+.1)
boxplot(expression_data, main="After background correction and normalisation",
xlab="Samples",ylab=expression('log'[2]*'(expression)'),cex=0.5, par(cex.lab=1.5),par(cex.axis=1.5))
dev.off()
#calculate no of samples below p values of 0.01
boolean_values<-detectionpvalues<0.01
count_true = data.frame(matrix(NA, nrow = nrow(detection_probe), ncol = 1))
count_false = data.frame(matrix(NA, nrow =nrow(detection_probe), ncol = 1))
percent_true = data.frame(matrix(NA, nrow = nrow(detection_probe), ncol = 1))
for (row in 1:nrow(detection_probe)){
count_true[row,1]<-length(boolean_values[row,][boolean_values[row,]==TRUE])
count_false[row,1]<-length(boolean_values[row,][boolean_values[row,]==FALSE])
percent_true[row,1]<-count_true[row,1]*100/54
}
View(detection_probe)
#ouput the normalized data
write.table(expression_data, "normalised-data.txt", na ="", row.names=TRUE,  sep='\t', quote=FALSE)
# input normalized data, generate an ExpressionSet object for illumina analysis, extract sample name
trans_data <- read.table("normalised-data.txt", header = TRUE, sep = '\t', stringsAsFactors = FALSE)
trans_matrix <- as.matrix(trans_data)
eset <- ExpressionSet(trans_matrix, annotation=rownames(trans_data))
samples_name <- data.frame(sampleID = colnames(trans_data), stringsAsFactors = FALSE)
#extract categories for design matrix
Timepoint_diet <- paste(targets$Timepoint, targets$Diet, sep=".")
Timepoint_diet<- factor(Timepoint_diet, levels=c("baseline.Ex_diet", "end.Ex_diet", "baseline.C_diet", "end.C_diet"))
#Make design matrix and fit model
design <- model.matrix(~0+Timepoint_diet)
colnames(design)<-levels(Timepoint_diet)
fit <- lmFit(eset, design)
#Make contrast matrix
cont.matrix <- makeContrasts(
ExDiet_end_vs_baseline=end.Ex_diet-baseline.Ex_diet,
CDiet_end_vs_baseline=end.C_diet-baseline.C_diet,
levels=design)
fit2 <- contrasts.fit(fit, cont.matrix)
fit2 <- eBayes(fit2)
TopTable_Ex_diet <- topTable(fit2, adjust.method="BH", coef="ExDiet_end_vs_baseline", number=Inf)
TopTable_C_diet <- topTable(fit2, adjust.method="BH", coef="CDiet_end_vs_baseline", number=Inf)
# Add the Entrez Gene IDs as a column to the TopTables
TopTable_Ex_diet <- rownames_to_column(TopTable_Ex_diet, "Entrez_ID" )
TopTable_C_diet <- rownames_to_column(TopTable_C_diet, "Entrez_ID")
subset_annot <- subset(annot, select = c(Entrez_Gene_ID, Symbol))
subset_annot <- unique(subset_annot)
TopTable_Ex_diet <- merge(TopTable_Ex_diet, subset_annot, by.x="Entrez_ID", by.y="Entrez_Gene_ID")
TopTable_C_diet <- merge(TopTable_C_diet, subset_annot, by.x="Entrez_ID", by.y="Entrez_Gene_ID")
write.table(TopTable_Ex_diet, file = "TopTable_Ex-diet.csv", sep=",", row.names=FALSE)
write.table(TopTable_C_diet, file = "TopTable_C-diet.csv", sep=",", row.names=FALSE)
View(eset)
eset@phenoData
View(TopTable_Ex_diet)
View(design)
if (!("BiocManager" %in% installed.packages())) { install.packages("BiocManager") }
if (!("rstudioapi" %in% installed.packages())) { BiocManager::install("rstudioapi") }
# if you get a non-zero exit status for org.Hs.eg.db - run the following line twice
if (!("org.Hs.eg.db" %in% installed.packages())) { BiocManager::install("org.Hs.eg.db") }
if (!("dplyr" %in% installed.packages())) { BiocManager::install("dplyr") }
if (!("EnhancedVolcano" %in% installed.packages())) { BiocManager::install("EnhancedVolcano") }
if (!("clusterProfiler" %in% installed.packages())) { BiocManager::install("clusterProfiler") }
if (!("enrichplot" %in% installed.packages())) { BiocManager::install("enrichplot") }
if (!("Rgraphviz" %in% installed.packages())) { BiocManager::install("Rgraphviz") }
if (!("readr" %in% installed.packages())) { BiocManager::install("readr") }
if (!("RColorBrewer" %in% installed.packages())) { BiocManager::install("RColorBrewer") }
if (!("RCy3" %in% installed.packages())) { BiocManager::install("RCy3") }
library(rstudioapi)
library(org.Hs.eg.db)
library(dplyr)
library(EnhancedVolcano)
library(clusterProfiler)
library(enrichplot)
library(Rgraphviz)
BiocManager::install("Rgraphviz")
library(rstudioapi)
library(org.Hs.eg.db)
library(dplyr)
library(EnhancedVolcano)
library(clusterProfiler)
library(enrichplot)
library(Rgraphviz)
library(readr)
library(RColorBrewer)
library(RCy3)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
out.folder <- "output/"
dir.create(out.folder)
options(scipen=999)
# importing CD gene expression dataset
data <- read.table("CD-dataset.tsv", header=TRUE, sep = "\t", dec = ".")
options(scipen=999)
# importing CD gene expression dataset
data <- read.table("CD-dataset.tsv", header=TRUE, sep = "\t", dec = ".")
View(data)
logfc.cutoff <- 0.58
pvalue.cutoff <- 0.05
degs <- data[abs(data$log2FC) > logfc.cutoff & data$pvalue < pvalue.cutoff,]
write.table(degs, file=paste0(out.folder,"degs.tsv"), row.names = FALSE, sep="\t", quote = FALSE)
View(degs)
filename <- paste0(out.folder,"CD-volcano.png")
png(filename , width = 2000, height = 1500, res = 150)
EnhancedVolcano::EnhancedVolcano(data, title = paste0(nrow(degs), " DEGs"), lab = data$GeneSymbol, x = "log2FC", y = "pvalue", pCutoff = pvalue.cutoff, FCcutoff = logfc.cutoff, labSize = 3, xlim = c(-3.5,3.5), ylim=c(0,10))
dev.off()
res.wp <- clusterProfiler::enrichWP(degs$ENTREZ.ID, organism = "Homo sapiens", pAdjustMethod = "fdr", pvalueCutoff = 0.05, minGSSize = 20, maxGSSize = 400)
res.wp.df <- as.data.frame(res.wp)
View(res.wp)
num <- nrow(as.data.frame(res.wp))
print(paste0(num, " significant pathways"))
write.table(as.data.frame(res.wp), file=paste0(out.folder,"wikipathways-ora.txt"), sep="\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
View(res.wp.df)
num <- nrow(as.data.frame(res.wp))
print(paste0(num, " significant pathways"))
write.table(as.data.frame(res.wp), file=paste0(out.folder,"wikipathways-ora.txt"), sep="\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
res.wp.sim <- enrichplot::pairwise_termsim(res.wp)
ep <- emapplot(res.wp.sim, showCategory = num)
tp <- treeplot(res.wp.sim, label_format = 0.5, cluster.params = list(n = 15), showCategory = num)
filename <- paste0(out.folder,"WikiPathways_ORA_Emappplot.png")
png(filename , width = 3000, height = 4000, res = 150)
plot(ep)
dev.off()
filename <- paste0(out.folder,"WikiPathways_ORA_Treeplot.png")
png(filename , width = 3000, height = 4000, res = 150)
plot(tp)
dev.off()
View(res.wp.sim)
View(res.wp.df)
RCy3::cytoscapePing()
RCy3::cytoscapePing()
RCy3::installApp("wikipathways")
RCy3::commandsRun('wikipathways import-as-pathway id=WP545')
toggleGraphicsDetails()
loadTableData(data, data.key.column = "Ensembl.ID", table.key.column = "Ensembl")
control.points <- c (-1.0, 0.0, 1.0)
colors <-  c ('#5588DD', '#FFFFFF', '#DD8855')
setNodeColorMapping("log2FC", control.points, colors, style.name = "WikiPathways")
View(res.wp.df)
if (!("BiocManager" %in% installed.packages())) { install.packages("BiocManager") }
if (!("rstudioapi" %in% installed.packages())) { BiocManager::install("rstudioapi") }
if (!("dplyr" %in% installed.packages())) { BiocManager::install("dplyr") }
if (!("readr" %in% installed.packages())) { BiocManager::install("readr") }
if (!("RCy3" %in% installed.packages())) { BiocManager::install("RCy3") }
if (!("randomcoloR" %in% installed.packages())) { BiocManager::install("randomcoloR") }
library(rstudioapi)
library(dplyr)
library(readr)
library(RCy3)
library(randomcoloR)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
out.folder <- "output/"
dir.create(out.folder)
options(scipen=999)
# importing CD gene expression dataset
data <- read.table("CD-dataset.tsv", header=TRUE, sep = "\t", dec = ".")
logfc.cutoff <- 0.58
pvalue.cutoff <- 0.05
degs <- data[abs(data$log2FC) > logfc.cutoff & data$pvalue < pvalue.cutoff,]
RCy3::cytoscapePing()
# the first time install the stringApp
installApp('stringApp')
query <- format_csv(as.data.frame(degs$ENTREZ.ID), col_names=F, escape = "double", eol =",")
commandsRun(paste0('string protein query cutoff=0.7 newNetName="PPI network" query="',query,'" limit=0'))
RCy3::commandsRun('network select subnetwork createSubnetwork=TRUE')
RCy3::analyzeNetwork()
RCy3::createVisualStyle("log2FC vis")
RCy3::setNodeLabelMapping("display name", style.name = "log2FC vis")
RCy3::setNodeSizeMapping("Degree", table.column.values = c(1,90), sizes = c(30,150), mapping.type = "c", default.size = 30, style.name = "log2FC vis")
RCy3::setNodeColorDefault("#E5F5E0", style.name = "log2FC vis")
RCy3::setVisualStyle("log2FC vis")
RCy3::clearSelection()
RCy3::exportPNG(paste0(out.folder,"PPI-degree.png"), allGraphicsDetails = TRUE, zoom = 500)
query <- format_csv(as.data.frame(degs$ENTREZ.ID), col_names=F, escape = "double", eol =",")
commandsRun(paste0('string protein query cutoff=0.7 newNetName="PPI network" query="',query,'" limit=0'))
# What happens if you change the node size mapping based on the betweenness? how would you interpret this result?
RCy3::setNodeSizeMapping("BetweennessCentrality", table.column.values = c(0,0.5), sizes = c(30,150), mapping.type = "c", default.size = 30, style.name = "log2FC vis")
# let's extract the largest connected compontent
RCy3::commandsRun('network select subnetwork createSubnetwork=TRUE')
RCy3::analyzeNetwork()
RCy3::createVisualStyle("log2FC vis")
RCy3::setNodeLabelMapping("display name", style.name = "log2FC vis")
RCy3::setNodeSizeMapping("Degree", table.column.values = c(1,90), sizes = c(30,150), mapping.type = "c", default.size = 30, style.name = "log2FC vis")
RCy3::setNodeColorDefault("#E5F5E0", style.name = "log2FC vis")
RCy3::setVisualStyle("log2FC vis")
RCy3::clearSelection()
RCy3::exportPNG(paste0(out.folder,"PPI-degree.png"), allGraphicsDetails = TRUE, zoom = 500)
# Look at the network. Do you see any hub nodes? Where are they located?
RCy3::setNodeSizeMapping("BetweennessCentrality", table.column.values = c(0,0.5), sizes = c(30,150), mapping.type = "c", default.size = 30, style.name = "log2FC vis")
RCy3::exportPNG(paste0(out.folder,"PPI-betweenness.png"),  allGraphicsDetails = TRUE, zoom = 500)
# What happens if you change the node size mapping based on the clustering coefficient? how would you interpret this result?
RCy3::setNodeSizeMapping("ClusteringCoefficient", table.column.values = c(0,1), sizes = c(30,150), mapping.type = "c", default.size = 30, style.name = "log2FC vis")
RCy3::exportPNG(paste0(out.folder,"PPI-clusteringcoefficient.png"),  allGraphicsDetails = TRUE, zoom = 500)
loadTableData(data, data.key.column = "ENTREZ.ID", table.key.column = "query term")
control.points <- c (-2.0, 0.0, 2.0)
colors <-  c ('#5588DD', '#FFFFFF', '#DD8855')
setNodeColorMapping("log2FC", control.points, colors, style.name = "log2FC vis")
RCy3::exportPNG(paste0(out.folder,"PPI-log2FC.png"), zoom = 500)
RCy3::installApp("clustermaker2")
suid <- RCy3::getNetworkSuid()
RCy3::commandsRun(paste0("cluster glay network=",suid))
RCy3::commandsRun(paste0("cluster glay network=",suid))
RCy3::commandsRun(paste0("cluster glay network=",suid))
RCy3::installApp("clustermaker2")
suid <- RCy3::getNetworkSuid()
# this algorithm has a random component so it might look slightly different if you rerun it again
RCy3::commandsRun(paste0("cluster glay network=",suid))
clusters <- RCy3::getTableColumns(columns=c("SUID", "__glayCluster"))
RCy3::copyVisualStyle("log2FC vis", "clusters")
num.c <- length(unique(clusters$`__glayCluster`))
palette <- distinctColorPalette(num.c)
setNodeColorMapping("__glayCluster",table.column.values = c(1:num.c), colors = palette, mapping.type = "d", style.name = "clusters")
setVisualStyle("clusters")
RCy3::exportPNG(paste0(out.folder,"PPI-clustered.png"), zoom = 500)
View(clusters)
nodes.c1 <- clusters[clusters$`__glayCluster`==1,]
RCy3::selectNodes(nodes.c1$SUID)
RCy3::createSubnetwork(nodes.c1$SUID)
RCy3::setVisualStyle("log2FC vis")
RCy3::exportPNG(paste0(out.folder,"PPI-cluster1.png"), zoom = 500)
RCy3::commandsRun(paste0('string retrieve enrichment allNetSpecies="Homo sapiens"'))
RCy3::commandsRun('string show enrichment')
RCy3::saveSession(filename=paste0(out.folder,"PPI.cys"))
